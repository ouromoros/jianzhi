# 数组中的逆序对
刚开始我想到的是类似标准答案的解法，也就是使用MergeSort然后在过程中计算逆序对的个数，不过总觉得这样十分麻烦，就又想到了利用平衡树的更简洁的解法（不过因为我懒得手写平衡树，就没有实现）。

这个解法依赖于可以快速求出大于一个结点的数的个数的平衡树，在这个平衡树中每个结点都保存它左结点中地结点地个数，仔细思考一下的话插入的复杂度不变，是O(log(n))，计算小于一个数的数的个数也很简单，在普通的递归寻找过程中根据查找的是左/右子树选择是否加上右子树中结点的个数即可，复杂度也是O(log(n))。算法就是从后往前向树中插入数，并给总和加上树中已经有的比它小的结点个数即可，总复杂度为O(n*log(n))。
